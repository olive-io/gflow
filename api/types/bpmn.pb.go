// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: types/bpmn.proto

package types

import (
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/golang/protobuf/proto"
	_ "github.com/srikrsna/protoc-gen-gotag/tagger"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

type FlowNodeType int32

const (
	FlowNodeType_UnknownNode            FlowNodeType = 0
	FlowNodeType_StartEvent             FlowNodeType = 1
	FlowNodeType_EndEvent               FlowNodeType = 2
	FlowNodeType_BoundaryEvent          FlowNodeType = 3
	FlowNodeType_IntermediateCatchEvent FlowNodeType = 4
	FlowNodeType_Task                   FlowNodeType = 11
	FlowNodeType_SendTask               FlowNodeType = 12
	FlowNodeType_ReceiveTask            FlowNodeType = 13
	FlowNodeType_ServiceTask            FlowNodeType = 14
	FlowNodeType_UserTask               FlowNodeType = 15
	FlowNodeType_ScriptTask             FlowNodeType = 16
	FlowNodeType_ManualTask             FlowNodeType = 17
	FlowNodeType_CallActivity           FlowNodeType = 18
	FlowNodeType_BusinessRuleTask       FlowNodeType = 19
	FlowNodeType_SubProcess             FlowNodeType = 20
	FlowNodeType_EventBasedGateway      FlowNodeType = 31
	FlowNodeType_ExclusiveGateway       FlowNodeType = 32
	FlowNodeType_InclusiveGateway       FlowNodeType = 33
	FlowNodeType_ParallelGateway        FlowNodeType = 34
)

var FlowNodeType_name = map[int32]string{
	0:  "UnknownNode",
	1:  "StartEvent",
	2:  "EndEvent",
	3:  "BoundaryEvent",
	4:  "IntermediateCatchEvent",
	11: "Task",
	12: "SendTask",
	13: "ReceiveTask",
	14: "ServiceTask",
	15: "UserTask",
	16: "ScriptTask",
	17: "ManualTask",
	18: "CallActivity",
	19: "BusinessRuleTask",
	20: "SubProcess",
	31: "EventBasedGateway",
	32: "ExclusiveGateway",
	33: "InclusiveGateway",
	34: "ParallelGateway",
}

var FlowNodeType_value = map[string]int32{
	"UnknownNode":            0,
	"StartEvent":             1,
	"EndEvent":               2,
	"BoundaryEvent":          3,
	"IntermediateCatchEvent": 4,
	"Task":                   11,
	"SendTask":               12,
	"ReceiveTask":            13,
	"ServiceTask":            14,
	"UserTask":               15,
	"ScriptTask":             16,
	"ManualTask":             17,
	"CallActivity":           18,
	"BusinessRuleTask":       19,
	"SubProcess":             20,
	"EventBasedGateway":      31,
	"ExclusiveGateway":       32,
	"InclusiveGateway":       33,
	"ParallelGateway":        34,
}

func (x FlowNodeType) String() string {
	return proto.EnumName(FlowNodeType_name, int32(x))
}

func (FlowNodeType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_a39c931a76cbadd9, []int{0}
}

type Value_Type int32

const (
	Value_String  Value_Type = 0
	Value_Integer Value_Type = 1
	Value_Float   Value_Type = 2
	Value_Boolean Value_Type = 3
	Value_Array   Value_Type = 4
	Value_Object  Value_Type = 5
)

var Value_Type_name = map[int32]string{
	0: "String",
	1: "Integer",
	2: "Float",
	3: "Boolean",
	4: "Array",
	5: "Object",
}

var Value_Type_value = map[string]int32{
	"String":  0,
	"Integer": 1,
	"Float":   2,
	"Boolean": 3,
	"Array":   4,
	"Object":  5,
}

func (x Value_Type) String() string {
	return proto.EnumName(Value_Type_name, int32(x))
}

func (Value_Type) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_a39c931a76cbadd9, []int{0, 0}
}

type Process_ProcessStage int32

const (
	// to be 'Prepare' where Process created
	Process_Prepare Process_ProcessStage = 0
	// to be 'Ready' where olive-server scheduled
	Process_Ready    Process_ProcessStage = 1
	Process_Commit   Process_ProcessStage = 2
	Process_Rollback Process_ProcessStage = 3
	Process_Destroy  Process_ProcessStage = 4
	Process_Finish   Process_ProcessStage = 5
)

var Process_ProcessStage_name = map[int32]string{
	0: "Prepare",
	1: "Ready",
	2: "Commit",
	3: "Rollback",
	4: "Destroy",
	5: "Finish",
}

var Process_ProcessStage_value = map[string]int32{
	"Prepare":  0,
	"Ready":    1,
	"Commit":   2,
	"Rollback": 3,
	"Destroy":  4,
	"Finish":   5,
}

func (x Process_ProcessStage) String() string {
	return proto.EnumName(Process_ProcessStage_name, int32(x))
}

func (Process_ProcessStage) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_a39c931a76cbadd9, []int{4, 0}
}

type Process_ProcessStatus int32

const (
	Process_Waiting Process_ProcessStatus = 0
	Process_Running Process_ProcessStatus = 1
	Process_Success Process_ProcessStatus = 2
	Process_Warn    Process_ProcessStatus = 3
	Process_Failed  Process_ProcessStatus = 4
)

var Process_ProcessStatus_name = map[int32]string{
	0: "Waiting",
	1: "Running",
	2: "Success",
	3: "Warn",
	4: "Failed",
}

var Process_ProcessStatus_value = map[string]int32{
	"Waiting": 0,
	"Running": 1,
	"Success": 2,
	"Warn":    3,
	"Failed":  4,
}

func (x Process_ProcessStatus) String() string {
	return proto.EnumName(Process_ProcessStatus_name, int32(x))
}

func (Process_ProcessStatus) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_a39c931a76cbadd9, []int{4, 1}
}

type FlowNode_FlowNodeStage int32

const (
	FlowNode_Prepare  FlowNode_FlowNodeStage = 0
	FlowNode_Ready    FlowNode_FlowNodeStage = 1
	FlowNode_Commit   FlowNode_FlowNodeStage = 2
	FlowNode_Destroy  FlowNode_FlowNodeStage = 3
	FlowNode_Rollback FlowNode_FlowNodeStage = 4
	FlowNode_Finish   FlowNode_FlowNodeStage = 5
)

var FlowNode_FlowNodeStage_name = map[int32]string{
	0: "Prepare",
	1: "Ready",
	2: "Commit",
	3: "Destroy",
	4: "Rollback",
	5: "Finish",
}

var FlowNode_FlowNodeStage_value = map[string]int32{
	"Prepare":  0,
	"Ready":    1,
	"Commit":   2,
	"Destroy":  3,
	"Rollback": 4,
	"Finish":   5,
}

func (x FlowNode_FlowNodeStage) String() string {
	return proto.EnumName(FlowNode_FlowNodeStage_name, int32(x))
}

func (FlowNode_FlowNodeStage) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_a39c931a76cbadd9, []int{6, 0}
}

type FlowNode_FlowNodeStatus int32

const (
	FlowNode_Waiting FlowNode_FlowNodeStatus = 0
	FlowNode_Running FlowNode_FlowNodeStatus = 1
	FlowNode_Success FlowNode_FlowNodeStatus = 2
	FlowNode_Warn    FlowNode_FlowNodeStatus = 3
	FlowNode_Failed  FlowNode_FlowNodeStatus = 4
)

var FlowNode_FlowNodeStatus_name = map[int32]string{
	0: "Waiting",
	1: "Running",
	2: "Success",
	3: "Warn",
	4: "Failed",
}

var FlowNode_FlowNodeStatus_value = map[string]int32{
	"Waiting": 0,
	"Running": 1,
	"Success": 2,
	"Warn":    3,
	"Failed":  4,
}

func (x FlowNode_FlowNodeStatus) String() string {
	return proto.EnumName(FlowNode_FlowNodeStatus_name, int32(x))
}

func (FlowNode_FlowNodeStatus) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_a39c931a76cbadd9, []int{6, 1}
}

type Value struct {
	Type    Value_Type `protobuf:"varint,1,opt,name=type,proto3,enum=types.Value_Type" json:"type,omitempty"`
	Kind    string     `protobuf:"bytes,2,opt,name=kind,proto3" json:"kind,omitempty"`
	Value   string     `protobuf:"bytes,3,opt,name=value,proto3" json:"value,omitempty"`
	Default string     `protobuf:"bytes,4,opt,name=default,proto3" json:"default,omitempty"`
}

func (m *Value) Reset()         { *m = Value{} }
func (m *Value) String() string { return proto.CompactTextString(m) }
func (*Value) ProtoMessage()    {}
func (*Value) Descriptor() ([]byte, []int) {
	return fileDescriptor_a39c931a76cbadd9, []int{0}
}
func (m *Value) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Value) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Value.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Value) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Value.Merge(m, src)
}
func (m *Value) XXX_Size() int {
	return m.Size()
}
func (m *Value) XXX_DiscardUnknown() {
	xxx_messageInfo_Value.DiscardUnknown(m)
}

var xxx_messageInfo_Value proto.InternalMessageInfo

type Endpoint struct {
	Type        FlowNodeType `protobuf:"varint,1,opt,name=type,proto3,enum=types.FlowNodeType" json:"type,omitempty"`
	Kind        string       `protobuf:"bytes,2,opt,name=kind,proto3" json:"kind,omitempty"`
	Name        string       `protobuf:"bytes,3,opt,name=name,proto3" json:"name,omitempty"`
	Description string       `protobuf:"bytes,4,opt,name=description,proto3" json:"description,omitempty"`
	HttpUrl     string       `protobuf:"bytes,5,opt,name=http_url,json=httpUrl,proto3" json:"http_url,omitempty"`
	// request data
	Headers    map[string]string `protobuf:"bytes,11,rep,name=headers,proto3" json:"headers,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	Parameters map[string]*Value `protobuf:"bytes,12,rep,name=parameters,proto3" json:"parameters,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// response data
	Results map[string]*Value `protobuf:"bytes,13,rep,name=results,proto3" json:"results,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *Endpoint) Reset()         { *m = Endpoint{} }
func (m *Endpoint) String() string { return proto.CompactTextString(m) }
func (*Endpoint) ProtoMessage()    {}
func (*Endpoint) Descriptor() ([]byte, []int) {
	return fileDescriptor_a39c931a76cbadd9, []int{1}
}
func (m *Endpoint) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Endpoint) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Endpoint.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Endpoint) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Endpoint.Merge(m, src)
}
func (m *Endpoint) XXX_Size() int {
	return m.Size()
}
func (m *Endpoint) XXX_DiscardUnknown() {
	xxx_messageInfo_Endpoint.DiscardUnknown(m)
}

var xxx_messageInfo_Endpoint proto.InternalMessageInfo

// Definitions bpmn Definition
type Definitions struct {
	Id          int64             `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty" gorm:"primary"`
	Name        string            `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	CreateAt    int64             `protobuf:"varint,3,opt,name=create_at,json=createAt,proto3" json:"create_at,omitempty" gorm:"autoCreateTime"`
	UpdateAt    int64             `protobuf:"varint,4,opt,name=update_at,json=updateAt,proto3" json:"update_at,omitempty" gorm:"autoUpdateTime"`
	Uid         string            `protobuf:"bytes,5,opt,name=uid,proto3" json:"uid,omitempty" gorm:"index"`
	Description string            `protobuf:"bytes,6,opt,name=description,proto3" json:"description,omitempty"`
	Metadata    map[string]string `protobuf:"bytes,7,rep,name=metadata,proto3" json:"metadata,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3" gorm:"serializer:json"`
	Content     string            `protobuf:"bytes,8,opt,name=content,proto3" json:"content,omitempty"`
	Version     uint64            `protobuf:"varint,9,opt,name=version,proto3" json:"version,omitempty"`
	IsExecute   bool              `protobuf:"varint,10,opt,name=isExecute,proto3" json:"isExecute,omitempty"`
}

func (m *Definitions) Reset()         { *m = Definitions{} }
func (m *Definitions) String() string { return proto.CompactTextString(m) }
func (*Definitions) ProtoMessage()    {}
func (*Definitions) Descriptor() ([]byte, []int) {
	return fileDescriptor_a39c931a76cbadd9, []int{2}
}
func (m *Definitions) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Definitions) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Definitions.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Definitions) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Definitions.Merge(m, src)
}
func (m *Definitions) XXX_Size() int {
	return m.Size()
}
func (m *Definitions) XXX_DiscardUnknown() {
	xxx_messageInfo_Definitions.DiscardUnknown(m)
}

var xxx_messageInfo_Definitions proto.InternalMessageInfo

type BpmnArgs struct {
	Headers     map[string]string `protobuf:"bytes,1,rep,name=headers,proto3" json:"headers,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	Properties  map[string]*Value `protobuf:"bytes,2,rep,name=properties,proto3" json:"properties,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	DataObjects map[string]*Value `protobuf:"bytes,3,rep,name=dataObjects,proto3" json:"dataObjects,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *BpmnArgs) Reset()         { *m = BpmnArgs{} }
func (m *BpmnArgs) String() string { return proto.CompactTextString(m) }
func (*BpmnArgs) ProtoMessage()    {}
func (*BpmnArgs) Descriptor() ([]byte, []int) {
	return fileDescriptor_a39c931a76cbadd9, []int{3}
}
func (m *BpmnArgs) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BpmnArgs) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BpmnArgs.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BpmnArgs) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BpmnArgs.Merge(m, src)
}
func (m *BpmnArgs) XXX_Size() int {
	return m.Size()
}
func (m *BpmnArgs) XXX_DiscardUnknown() {
	xxx_messageInfo_BpmnArgs.DiscardUnknown(m)
}

var xxx_messageInfo_BpmnArgs proto.InternalMessageInfo

type Process struct {
	Id                 int64                 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty" gorm:"primary"`
	CreateAt           int64                 `protobuf:"varint,2,opt,name=create_at,json=createAt,proto3" json:"create_at,omitempty" gorm:"autoCreateTime"`
	UpdateAt           int64                 `protobuf:"varint,3,opt,name=update_at,json=updateAt,proto3" json:"update_at,omitempty" gorm:"autoUpdateTime"`
	Name               string                `protobuf:"bytes,4,opt,name=name,proto3" json:"name,omitempty"`
	Uid                string                `protobuf:"bytes,5,opt,name=uid,proto3" json:"uid,omitempty"`
	Metadata           map[string]string     `protobuf:"bytes,6,rep,name=metadata,proto3" json:"metadata,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3" gorm:"serializer:json"`
	Priority           int64                 `protobuf:"varint,7,opt,name=priority,proto3" json:"priority,omitempty"`
	Args               *BpmnArgs             `protobuf:"bytes,8,opt,name=args,proto3" json:"args,omitempty" gorm:"serializer:json"`
	DefinitionsUid     string                `protobuf:"bytes,9,opt,name=definitions_uid,json=definitionsUid,proto3" json:"definitions_uid,omitempty" gorm:"index"`
	DefinitionsVersion uint64                `protobuf:"varint,10,opt,name=definitions_version,json=definitionsVersion,proto3" json:"definitions_version,omitempty"`
	DefinitionsProcess string                `protobuf:"bytes,11,opt,name=definitions_process,json=definitionsProcess,proto3" json:"definitions_process,omitempty"`
	Context            *ProcessContext       `protobuf:"bytes,12,opt,name=context,proto3" json:"context,omitempty" gorm:"serializer:json"`
	Attempts           int32                 `protobuf:"varint,13,opt,name=attempts,proto3" json:"attempts,omitempty"`
	StartAt            int64                 `protobuf:"varint,14,opt,name=start_at,json=startAt,proto3" json:"start_at,omitempty"`
	EndAt              int64                 `protobuf:"varint,15,opt,name=end_at,json=endAt,proto3" json:"end_at,omitempty"`
	Stage              Process_ProcessStage  `protobuf:"varint,16,opt,name=stage,proto3,enum=types.Process_ProcessStage" json:"stage,omitempty"`
	Status             Process_ProcessStatus `protobuf:"varint,17,opt,name=status,proto3,enum=types.Process_ProcessStatus" json:"status,omitempty"`
	ErrMsg             string                `protobuf:"bytes,18,opt,name=err_msg,json=errMsg,proto3" json:"err_msg,omitempty"`
}

func (m *Process) Reset()         { *m = Process{} }
func (m *Process) String() string { return proto.CompactTextString(m) }
func (*Process) ProtoMessage()    {}
func (*Process) Descriptor() ([]byte, []int) {
	return fileDescriptor_a39c931a76cbadd9, []int{4}
}
func (m *Process) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Process) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Process.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Process) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Process.Merge(m, src)
}
func (m *Process) XXX_Size() int {
	return m.Size()
}
func (m *Process) XXX_DiscardUnknown() {
	xxx_messageInfo_Process.DiscardUnknown(m)
}

var xxx_messageInfo_Process proto.InternalMessageInfo

type ProcessContext struct {
	Variables   map[string]*Value `protobuf:"bytes,1,rep,name=variables,proto3" json:"variables,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	DataObjects map[string]*Value `protobuf:"bytes,2,rep,name=dataObjects,proto3" json:"dataObjects,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *ProcessContext) Reset()         { *m = ProcessContext{} }
func (m *ProcessContext) String() string { return proto.CompactTextString(m) }
func (*ProcessContext) ProtoMessage()    {}
func (*ProcessContext) Descriptor() ([]byte, []int) {
	return fileDescriptor_a39c931a76cbadd9, []int{5}
}
func (m *ProcessContext) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ProcessContext) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ProcessContext.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ProcessContext) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ProcessContext.Merge(m, src)
}
func (m *ProcessContext) XXX_Size() int {
	return m.Size()
}
func (m *ProcessContext) XXX_DiscardUnknown() {
	xxx_messageInfo_ProcessContext.DiscardUnknown(m)
}

var xxx_messageInfo_ProcessContext proto.InternalMessageInfo

type FlowNode struct {
	Id          int64                   `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty" gorm:"primary"`
	CreateAt    int64                   `protobuf:"varint,2,opt,name=create_at,json=createAt,proto3" json:"create_at,omitempty" gorm:"autoCreateTime"`
	Name        string                  `protobuf:"bytes,3,opt,name=name,proto3" json:"name,omitempty"`
	FlowId      string                  `protobuf:"bytes,4,opt,name=flow_id,json=flowId,proto3" json:"flow_id,omitempty"`
	FlowType    FlowNodeType            `protobuf:"varint,5,opt,name=flow_type,json=flowType,proto3,enum=types.FlowNodeType" json:"flow_type,omitempty"`
	Headers     map[string]string       `protobuf:"bytes,6,rep,name=headers,proto3" json:"headers,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3" gorm:"serializer:json"`
	Properties  map[string]*Value       `protobuf:"bytes,7,rep,name=properties,proto3" json:"properties,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3" gorm:"serializer:json"`
	DataObjects map[string]*Value       `protobuf:"bytes,8,rep,name=data_objects,json=dataObjects,proto3" json:"data_objects,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3" gorm:"serializer:json"`
	Results     map[string]*Value       `protobuf:"bytes,9,rep,name=results,proto3" json:"results,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3" gorm:"serializer:json"`
	Retries     int32                   `protobuf:"varint,10,opt,name=retries,proto3" json:"retries,omitempty"`
	StartTime   int64                   `protobuf:"varint,11,opt,name=startTime,proto3" json:"startTime,omitempty"`
	EndTime     int64                   `protobuf:"varint,12,opt,name=endTime,proto3" json:"endTime,omitempty"`
	ProcessId   int64                   `protobuf:"varint,13,opt,name=process_id,json=processId,proto3" json:"process_id,omitempty" gorm:"index"`
	ProcessUid  string                  `protobuf:"bytes,14,opt,name=process_uid,json=processUid,proto3" json:"process_uid,omitempty"`
	Stage       FlowNode_FlowNodeStage  `protobuf:"varint,15,opt,name=stage,proto3,enum=types.FlowNode_FlowNodeStage" json:"stage,omitempty"`
	Status      FlowNode_FlowNodeStatus `protobuf:"varint,16,opt,name=status,proto3,enum=types.FlowNode_FlowNodeStatus" json:"status,omitempty"`
	ErrMsg      string                  `protobuf:"bytes,17,opt,name=err_msg,json=errMsg,proto3" json:"err_msg,omitempty"`
}

func (m *FlowNode) Reset()         { *m = FlowNode{} }
func (m *FlowNode) String() string { return proto.CompactTextString(m) }
func (*FlowNode) ProtoMessage()    {}
func (*FlowNode) Descriptor() ([]byte, []int) {
	return fileDescriptor_a39c931a76cbadd9, []int{6}
}
func (m *FlowNode) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FlowNode) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FlowNode.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FlowNode) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FlowNode.Merge(m, src)
}
func (m *FlowNode) XXX_Size() int {
	return m.Size()
}
func (m *FlowNode) XXX_DiscardUnknown() {
	xxx_messageInfo_FlowNode.DiscardUnknown(m)
}

var xxx_messageInfo_FlowNode proto.InternalMessageInfo

func init() {
	proto.RegisterEnum("types.FlowNodeType", FlowNodeType_name, FlowNodeType_value)
	proto.RegisterEnum("types.Value_Type", Value_Type_name, Value_Type_value)
	proto.RegisterEnum("types.Process_ProcessStage", Process_ProcessStage_name, Process_ProcessStage_value)
	proto.RegisterEnum("types.Process_ProcessStatus", Process_ProcessStatus_name, Process_ProcessStatus_value)
	proto.RegisterEnum("types.FlowNode_FlowNodeStage", FlowNode_FlowNodeStage_name, FlowNode_FlowNodeStage_value)
	proto.RegisterEnum("types.FlowNode_FlowNodeStatus", FlowNode_FlowNodeStatus_name, FlowNode_FlowNodeStatus_value)
	proto.RegisterType((*Value)(nil), "types.Value")
	proto.RegisterType((*Endpoint)(nil), "types.Endpoint")
	proto.RegisterMapType((map[string]string)(nil), "types.Endpoint.HeadersEntry")
	proto.RegisterMapType((map[string]*Value)(nil), "types.Endpoint.ParametersEntry")
	proto.RegisterMapType((map[string]*Value)(nil), "types.Endpoint.ResultsEntry")
	proto.RegisterType((*Definitions)(nil), "types.Definitions")
	proto.RegisterMapType((map[string]string)(nil), "types.Definitions.MetadataEntry")
	proto.RegisterType((*BpmnArgs)(nil), "types.BpmnArgs")
	proto.RegisterMapType((map[string]*Value)(nil), "types.BpmnArgs.DataObjectsEntry")
	proto.RegisterMapType((map[string]string)(nil), "types.BpmnArgs.HeadersEntry")
	proto.RegisterMapType((map[string]*Value)(nil), "types.BpmnArgs.PropertiesEntry")
	proto.RegisterType((*Process)(nil), "types.Process")
	proto.RegisterMapType((map[string]string)(nil), "types.Process.MetadataEntry")
	proto.RegisterType((*ProcessContext)(nil), "types.ProcessContext")
	proto.RegisterMapType((map[string]*Value)(nil), "types.ProcessContext.DataObjectsEntry")
	proto.RegisterMapType((map[string]*Value)(nil), "types.ProcessContext.VariablesEntry")
	proto.RegisterType((*FlowNode)(nil), "types.FlowNode")
	proto.RegisterMapType((map[string]*Value)(nil), "types.FlowNode.DataObjectsEntry")
	proto.RegisterMapType((map[string]string)(nil), "types.FlowNode.HeadersEntry")
	proto.RegisterMapType((map[string]*Value)(nil), "types.FlowNode.PropertiesEntry")
	proto.RegisterMapType((map[string]*Value)(nil), "types.FlowNode.ResultsEntry")
}

func init() { proto.RegisterFile("types/bpmn.proto", fileDescriptor_a39c931a76cbadd9) }

var fileDescriptor_a39c931a76cbadd9 = []byte{
	// 1670 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xdc, 0x58, 0x4f, 0x73, 0x1b, 0x49,
	0x15, 0xf7, 0x68, 0x24, 0x4b, 0x7a, 0x92, 0xe5, 0x71, 0x3b, 0xd9, 0x1d, 0xbc, 0x41, 0x31, 0x5a,
	0xfe, 0x18, 0xaa, 0x90, 0x97, 0x2c, 0xb5, 0x50, 0xde, 0x03, 0x58, 0x8e, 0x43, 0x0c, 0xc9, 0xae,
	0x6b, 0x1c, 0x67, 0x6b, 0xb7, 0xa8, 0x32, 0x6d, 0x4d, 0x47, 0xee, 0xf5, 0xa8, 0x67, 0xaa, 0xbb,
	0x47, 0x89, 0x38, 0xf3, 0x01, 0x38, 0x52, 0x14, 0xec, 0x99, 0x8f, 0xc0, 0x99, 0xd3, 0x1e, 0xf7,
	0xc8, 0x11, 0x12, 0x2e, 0x7c, 0x0b, 0xea, 0x75, 0xcf, 0x48, 0x33, 0x42, 0x71, 0x76, 0x63, 0xa8,
	0xa2, 0xb8, 0xc4, 0xf3, 0xfe, 0xfc, 0x5e, 0xbf, 0x7e, 0xfd, 0xfe, 0x29, 0xe0, 0xe9, 0x69, 0xc2,
	0xd4, 0xee, 0x79, 0x32, 0x16, 0xfd, 0x44, 0xc6, 0x3a, 0x26, 0x35, 0xc3, 0xd9, 0xda, 0xd4, 0x74,
	0x34, 0x62, 0x72, 0xd7, 0xfe, 0xb1, 0xb2, 0xad, 0x1b, 0xa3, 0x78, 0x14, 0x9b, 0xcf, 0x5d, 0xfc,
	0xb2, 0xdc, 0xde, 0x5f, 0x1c, 0xa8, 0x3d, 0xa6, 0x51, 0xca, 0xc8, 0xb7, 0xa0, 0x8a, 0x68, 0xdf,
	0xd9, 0x76, 0x76, 0x3a, 0x77, 0x36, 0xfa, 0xc6, 0x54, 0xdf, 0xc8, 0xfa, 0x8f, 0xa6, 0x09, 0x0b,
	0x8c, 0x98, 0x10, 0xa8, 0x5e, 0x72, 0x11, 0xfa, 0x95, 0x6d, 0x67, 0xa7, 0x19, 0x98, 0x6f, 0x72,
	0x03, 0x6a, 0x13, 0xd4, 0xf3, 0x5d, 0xc3, 0xb4, 0x04, 0xf1, 0xa1, 0x1e, 0xb2, 0x27, 0x34, 0x8d,
	0xb4, 0x5f, 0x35, 0xfc, 0x9c, 0xec, 0x7d, 0x00, 0x55, 0xb4, 0x48, 0x00, 0x56, 0x4f, 0xb4, 0xe4,
	0x62, 0xe4, 0xad, 0x90, 0x16, 0xd4, 0x8f, 0x84, 0x66, 0x23, 0x26, 0x3d, 0x87, 0x34, 0xa1, 0x76,
	0x2f, 0x8a, 0xa9, 0xf6, 0x2a, 0xc8, 0x1f, 0xc4, 0x71, 0xc4, 0xa8, 0xf0, 0x5c, 0xe4, 0xef, 0x4b,
	0x49, 0xa7, 0x5e, 0x15, 0xb1, 0x1f, 0x9e, 0x7f, 0xca, 0x86, 0xda, 0xab, 0xf5, 0xfe, 0x50, 0x85,
	0xc6, 0xa1, 0x08, 0x93, 0x98, 0x0b, 0x4d, 0xbe, 0x53, 0xba, 0xc7, 0x66, 0x76, 0x8f, 0x7b, 0x51,
	0xfc, 0xf4, 0x83, 0x38, 0x64, 0xaf, 0xb8, 0x09, 0x81, 0xaa, 0xa0, 0xe3, 0xfc, 0x22, 0xe6, 0x9b,
	0x6c, 0x43, 0x2b, 0x64, 0x6a, 0x28, 0x79, 0xa2, 0x79, 0x2c, 0xb2, 0xbb, 0x14, 0x59, 0xe4, 0x6b,
	0xd0, 0xb8, 0xd0, 0x3a, 0x39, 0x4b, 0x65, 0xe4, 0xd7, 0xec, 0x55, 0x91, 0x3e, 0x95, 0x11, 0x79,
	0x0f, 0xea, 0x17, 0x8c, 0x86, 0x4c, 0x2a, 0xbf, 0xb5, 0xed, 0xee, 0xb4, 0xee, 0xdc, 0xca, 0x1c,
	0xca, 0xfd, 0xed, 0xdf, 0xb7, 0xe2, 0x43, 0xa1, 0xe5, 0x34, 0xc8, 0x95, 0xc9, 0x4f, 0x00, 0x12,
	0x2a, 0xe9, 0x98, 0x69, 0x84, 0xb6, 0x0d, 0xf4, 0xf6, 0x22, 0xf4, 0x78, 0xa6, 0x61, 0xd1, 0x05,
	0x08, 0x1e, 0x2c, 0x99, 0x4a, 0x23, 0xad, 0xfc, 0xb5, 0xe5, 0x07, 0x07, 0x56, 0x9c, 0x1d, 0x9c,
	0x29, 0x6f, 0xed, 0x41, 0xbb, 0xe8, 0x11, 0xf1, 0xc0, 0xbd, 0x64, 0x53, 0x13, 0xcd, 0x66, 0x80,
	0x9f, 0xf3, 0xd7, 0xae, 0x14, 0x5e, 0x7b, 0xaf, 0xf2, 0x63, 0x67, 0xeb, 0x17, 0xb0, 0xbe, 0xe0,
	0xd2, 0x12, 0x78, 0xaf, 0x08, 0x6f, 0xdd, 0x69, 0x17, 0x13, 0xad, 0x68, 0xec, 0x3e, 0xb4, 0x8b,
	0x1e, 0xbe, 0xbe, 0xa5, 0xde, 0x3f, 0x5d, 0x68, 0xdd, 0x65, 0x4f, 0xb8, 0xe0, 0xf8, 0x5a, 0x8a,
	0xbc, 0x0d, 0x15, 0x1e, 0x1a, 0x43, 0xee, 0x60, 0xf3, 0xf7, 0xbf, 0xf9, 0xcc, 0xed, 0x8c, 0x62,
	0x39, 0xde, 0xeb, 0x25, 0x92, 0x8f, 0xa9, 0x9c, 0xf6, 0x82, 0x0a, 0x9f, 0x67, 0x42, 0xa5, 0x90,
	0x09, 0x3f, 0x82, 0xe6, 0x50, 0x32, 0xaa, 0xd9, 0x19, 0xd5, 0x26, 0x45, 0xdc, 0xc1, 0x16, 0xe2,
	0x6f, 0x5a, 0x3c, 0x4d, 0x75, 0x7c, 0x60, 0xe4, 0x8f, 0xf8, 0x98, 0xf5, 0x82, 0x86, 0x55, 0xde,
	0xd7, 0x08, 0x4c, 0x93, 0x30, 0x03, 0x56, 0x97, 0x02, 0x4f, 0x8d, 0x3c, 0x03, 0x5a, 0xe5, 0x7d,
	0x4d, 0xde, 0x06, 0x37, 0xe5, 0xa1, 0x4d, 0xaa, 0xc1, 0x06, 0x42, 0xda, 0x16, 0xc2, 0x45, 0xc8,
	0x9e, 0xf5, 0x02, 0x94, 0x2e, 0x26, 0xe8, 0xea, 0xbf, 0x27, 0xe8, 0xc7, 0xd0, 0x18, 0x33, 0x4d,
	0x43, 0xaa, 0xa9, 0x5f, 0x37, 0xd9, 0xb0, 0x9d, 0x05, 0xab, 0x10, 0x97, 0xfe, 0xc3, 0x4c, 0xc5,
	0xc4, 0x7b, 0xf0, 0x16, 0x9e, 0xf6, 0x86, 0x3d, 0x4d, 0x31, 0xc9, 0x69, 0xc4, 0x7f, 0xcd, 0xe4,
	0xde, 0xa7, 0x2a, 0x16, 0xbd, 0x60, 0x66, 0x0e, 0xab, 0x7c, 0x18, 0x0b, 0xcd, 0x84, 0xf6, 0x1b,
	0x36, 0xf5, 0x33, 0x12, 0x25, 0x13, 0x26, 0x15, 0xba, 0xd4, 0xdc, 0x76, 0x76, 0xaa, 0x41, 0x4e,
	0x92, 0x5b, 0xd0, 0xe4, 0xea, 0xf0, 0x19, 0x1b, 0xa6, 0x9a, 0xf9, 0xb0, 0xed, 0xec, 0x34, 0x82,
	0x39, 0x63, 0xeb, 0x7d, 0x58, 0x2b, 0x79, 0xf2, 0x55, 0x52, 0xb0, 0xf7, 0x99, 0x0b, 0x8d, 0x41,
	0x32, 0x16, 0xfb, 0x72, 0xa4, 0x8a, 0xc5, 0xe7, 0x94, 0x6a, 0x20, 0xd7, 0xb8, 0xa2, 0xf8, 0x64,
	0x9c, 0x30, 0xa9, 0x39, 0x53, 0x7e, 0xa5, 0x54, 0x7c, 0x33, 0xe8, 0xf1, 0x4c, 0x23, 0x2f, 0xbe,
	0x19, 0x83, 0x0c, 0xa0, 0x85, 0xee, 0xdb, 0x06, 0xa5, 0x7c, 0xb7, 0x14, 0xf2, 0x99, 0x85, 0xbb,
	0x73, 0x15, 0x6b, 0xa2, 0x08, 0xba, 0x76, 0x21, 0x96, 0xdd, 0xbb, 0x46, 0x21, 0x3e, 0x00, 0x6f,
	0xd1, 0xd3, 0x6b, 0x14, 0xe3, 0x1f, 0x1b, 0x50, 0x3f, 0x96, 0xf1, 0x90, 0xa9, 0x2f, 0x59, 0x88,
	0xa5, 0xa2, 0xab, 0xbc, 0x6e, 0xd1, 0xb9, 0x5f, 0xa1, 0xe8, 0xf2, 0xd2, 0xaf, 0x16, 0x4a, 0xdf,
	0x2b, 0x14, 0xa2, 0xad, 0xba, 0xd3, 0x42, 0x4d, 0xad, 0x96, 0xb2, 0x2b, 0xbb, 0xde, 0xeb, 0xd5,
	0xd3, 0x16, 0x34, 0x12, 0xc9, 0x63, 0xc9, 0xf5, 0xd4, 0xaf, 0xa3, 0xd3, 0xc1, 0x8c, 0x26, 0x3f,
	0x85, 0x2a, 0x95, 0x23, 0x65, 0x0a, 0xad, 0x75, 0x67, 0x7d, 0x21, 0x9f, 0xae, 0x3e, 0xc1, 0x20,
	0xc9, 0x1e, 0xac, 0x87, 0xf3, 0x8a, 0x3f, 0xc3, 0x2b, 0x35, 0x5f, 0xd6, 0x5b, 0x3a, 0x05, 0xcd,
	0x53, 0x1e, 0x92, 0x5d, 0xd8, 0x2c, 0x62, 0xf3, 0xda, 0x06, 0x53, 0xdb, 0xa4, 0x20, 0x7a, 0x9c,
	0x95, 0xf9, 0x02, 0x20, 0xb1, 0x61, 0xf1, 0x5b, 0x26, 0x86, 0x45, 0x40, 0x9e, 0x0f, 0x0f, 0xb2,
	0x5e, 0xf2, 0x4c, 0xfb, 0x6d, 0x73, 0xc5, 0x9b, 0xe5, 0x88, 0x1e, 0x58, 0xe1, 0xd5, 0x17, 0xcd,
	0x4d, 0x60, 0x24, 0xa9, 0xd6, 0x6c, 0x9c, 0x98, 0x11, 0xe8, 0xec, 0xd4, 0x82, 0x19, 0x8d, 0x13,
	0x5b, 0x69, 0x2a, 0x35, 0xa6, 0x46, 0xc7, 0x44, 0xb9, 0x6e, 0xe8, 0x7d, 0x4d, 0x6e, 0xc2, 0x2a,
	0x13, 0x21, 0x0a, 0xd6, 0x8d, 0xa0, 0xc6, 0x44, 0xb8, 0xaf, 0xc9, 0x0f, 0xa0, 0xa6, 0x34, 0x1d,
	0x31, 0xdf, 0x33, 0x7b, 0xc5, 0x5b, 0x0b, 0x6f, 0x9d, 0xfd, 0x3d, 0x41, 0x95, 0xc0, 0x6a, 0x92,
	0x1f, 0xc2, 0xaa, 0xd2, 0x54, 0xa7, 0xca, 0xdf, 0x30, 0x98, 0x5b, 0x2f, 0xc5, 0xe8, 0x54, 0x05,
	0x99, 0x2e, 0x79, 0x13, 0xea, 0x4c, 0xca, 0xb3, 0xb1, 0x1a, 0xf9, 0xc4, 0x44, 0x6a, 0x95, 0x49,
	0xf9, 0x50, 0x8d, 0xae, 0xd7, 0x17, 0x3f, 0x86, 0x76, 0xd1, 0x45, 0x5c, 0xab, 0x8e, 0x25, 0x4b,
	0xa8, 0x64, 0xde, 0x0a, 0xae, 0x55, 0x01, 0xa3, 0xe1, 0xd4, 0x73, 0x70, 0xad, 0x3a, 0x88, 0xc7,
	0x63, 0x8e, 0xab, 0x57, 0x1b, 0x1a, 0x41, 0x1c, 0x45, 0xe7, 0x74, 0x78, 0xe9, 0xb9, 0x88, 0xb8,
	0xcb, 0x94, 0x96, 0x71, 0xb6, 0x7d, 0xdd, 0xe3, 0x82, 0xab, 0x0b, 0xaf, 0xd6, 0x7b, 0x00, 0x6b,
	0xa5, 0x9b, 0xa0, 0xe6, 0x47, 0x94, 0xeb, 0xd9, 0x5e, 0x17, 0xa4, 0x42, 0x20, 0xe1, 0x20, 0x71,
	0x92, 0x0e, 0x51, 0xd5, 0xab, 0x90, 0x06, 0x54, 0x3f, 0xa2, 0x12, 0xd7, 0x3a, 0xb4, 0x46, 0x79,
	0xc4, 0x42, 0xaf, 0xda, 0xfb, 0x73, 0x05, 0x3a, 0xe5, 0xe7, 0x26, 0x03, 0x68, 0x4e, 0xa8, 0xe4,
	0xf4, 0x3c, 0x62, 0x79, 0x23, 0xff, 0xe6, 0xd2, 0xc4, 0xe8, 0x3f, 0xce, 0xd5, 0x6c, 0x3f, 0x9d,
	0xc3, 0xc8, 0xfd, 0x72, 0x47, 0xb6, 0x3d, 0xfd, 0xdb, 0xcb, 0xad, 0x5c, 0xdd, 0x97, 0x7f, 0x0e,
	0x9d, 0xf2, 0x31, 0xff, 0x33, 0xad, 0xf5, 0x4f, 0x00, 0x8d, 0x7c, 0xcf, 0xfd, 0x2f, 0xf7, 0xd6,
	0x65, 0x7b, 0xf2, 0x9b, 0x50, 0x7f, 0x12, 0xc5, 0x4f, 0xcf, 0x78, 0x98, 0x75, 0xce, 0x55, 0x24,
	0x8f, 0x42, 0xf2, 0x0e, 0x34, 0x8d, 0xc0, 0xac, 0xe5, 0xb5, 0x97, 0xaf, 0xe5, 0x0d, 0xd4, 0x32,
	0x3f, 0x0c, 0x4e, 0xe6, 0x83, 0xbb, 0xdc, 0x5a, 0x73, 0xfd, 0xd2, 0xe0, 0x7e, 0x45, 0x3f, 0xc8,
	0xa7, 0xfa, 0x2f, 0x4b, 0x53, 0xbd, 0x5e, 0x9a, 0xea, 0x33, 0xbb, 0x0b, 0x63, 0xf3, 0x6a, 0xd3,
	0xc5, 0x91, 0xff, 0x2b, 0x68, 0x63, 0x96, 0x9c, 0xc5, 0x59, 0x86, 0x35, 0x4a, 0x33, 0x7f, 0x66,
	0x7f, 0xf1, 0xb9, 0xaf, 0x3e, 0xa0, 0x98, 0x78, 0x18, 0x94, 0x7c, 0xa3, 0x6f, 0x2e, 0x0f, 0x4a,
	0x71, 0x5f, 0x7e, 0x45, 0x50, 0x32, 0x4b, 0xb8, 0xa4, 0x49, 0xa6, 0x25, 0x46, 0x04, 0x4c, 0x8f,
	0xcc, 0x49, 0x5c, 0xd2, 0x4c, 0x4b, 0xc4, 0xa7, 0x37, 0x3d, 0xdb, 0x0d, 0xe6, 0x0c, 0xc4, 0x31,
	0x11, 0x1a, 0x59, 0xdb, 0xf6, 0xcf, 0x8c, 0x24, 0xef, 0x98, 0x30, 0x63, 0x3d, 0x61, 0x26, 0xac,
	0x99, 0xa4, 0x5a, 0x32, 0x5d, 0x9a, 0x99, 0xd2, 0x51, 0x48, 0x6e, 0x43, 0x2b, 0x47, 0xe0, 0x40,
	0xea, 0x98, 0xe4, 0xc9, 0x8d, 0xe0, 0xe4, 0x79, 0x37, 0xef, 0xbd, 0xeb, 0x26, 0x79, 0xbe, 0xbe,
	0x78, 0xef, 0xfc, 0xa3, 0xd4, 0x7d, 0xdf, 0x9b, 0x75, 0x5f, 0xdb, 0xb1, 0xbb, 0x57, 0xa0, 0x5e,
	0xd2, 0x7f, 0x37, 0x4a, 0xfd, 0xf7, 0xff, 0x73, 0x21, 0xfb, 0x0f, 0xfe, 0xce, 0xfa, 0x04, 0xd6,
	0x4a, 0x2f, 0xf1, 0xa5, 0x86, 0x4c, 0x61, 0xac, 0xb8, 0xa5, 0x89, 0x53, 0x1e, 0x32, 0x0f, 0xa1,
	0x53, 0x7e, 0xaf, 0x6b, 0x4d, 0x99, 0xef, 0xfd, 0xa3, 0x02, 0xed, 0x62, 0xef, 0x21, 0xeb, 0xd0,
	0x3a, 0x15, 0x97, 0x22, 0x7e, 0x2a, 0x90, 0xe5, 0xad, 0x90, 0x0e, 0xc0, 0x09, 0x66, 0xfb, 0xe1,
	0x84, 0x09, 0xed, 0x39, 0xe8, 0xda, 0xa1, 0x08, 0x2d, 0x55, 0x21, 0x1b, 0xb0, 0x36, 0x88, 0x53,
	0x11, 0x52, 0x39, 0xb5, 0x2c, 0x97, 0x6c, 0xc1, 0x1b, 0x47, 0x42, 0x33, 0x39, 0x66, 0x21, 0xa7,
	0x9a, 0x1d, 0x50, 0x3d, 0xbc, 0xb0, 0xb2, 0x2a, 0x3a, 0xf1, 0x88, 0xaa, 0x4b, 0xaf, 0x85, 0x66,
	0x4e, 0xb0, 0x52, 0x90, 0x6a, 0xe3, 0xa9, 0x01, 0x1b, 0x32, 0x3e, 0x61, 0x86, 0xb1, 0x86, 0x8c,
	0x13, 0x26, 0x27, 0x7c, 0x68, 0x19, 0x1d, 0xd4, 0x3f, 0x55, 0x4c, 0x1a, 0x6a, 0xdd, 0x38, 0x65,
	0x7e, 0xd4, 0x19, 0xda, 0x43, 0xfa, 0x21, 0x15, 0x29, 0x8d, 0x0c, 0xbd, 0x41, 0x3c, 0x68, 0x1f,
	0xd0, 0x28, 0xda, 0x1f, 0x6a, 0x3e, 0xe1, 0x7a, 0xea, 0x11, 0x72, 0x03, 0xbc, 0x41, 0xaa, 0xb8,
	0x60, 0x4a, 0x05, 0x69, 0x64, 0xad, 0x6e, 0x1a, 0x3b, 0xe9, 0x79, 0x36, 0xf6, 0xbc, 0x1b, 0xe4,
	0x26, 0x6c, 0x18, 0x57, 0x07, 0x54, 0xb1, 0xf0, 0x67, 0x54, 0xb3, 0xa7, 0x74, 0xea, 0xdd, 0x46,
	0xf0, 0xe1, 0xb3, 0x61, 0x94, 0x2a, 0x3e, 0x61, 0x39, 0x77, 0x1b, 0xb9, 0x47, 0x62, 0x81, 0xfb,
	0x0d, 0xb2, 0x69, 0x7f, 0xfb, 0x47, 0x11, 0x8b, 0x72, 0x66, 0x6f, 0xa0, 0x3e, 0xff, 0x7b, 0x77,
	0xe5, 0xf3, 0xe7, 0x5d, 0xe7, 0x8b, 0xe7, 0x5d, 0xe7, 0x6f, 0xcf, 0xbb, 0xce, 0x6f, 0x5f, 0x74,
	0x57, 0x7e, 0xf7, 0xa2, 0xbb, 0xf2, 0xc5, 0x8b, 0xee, 0xca, 0x5f, 0x5f, 0x74, 0x57, 0xc0, 0xe7,
	0x71, 0x3f, 0x8e, 0xf8, 0x84, 0xf5, 0x47, 0xd8, 0xfd, 0xfb, 0x34, 0xe1, 0x36, 0xbd, 0x06, 0xf0,
	0x21, 0xb2, 0xf1, 0x71, 0xd4, 0xb1, 0xf3, 0xc9, 0x77, 0x47, 0x5c, 0x5f, 0xa4, 0xe7, 0xfd, 0x61,
	0x3c, 0xde, 0x35, 0xfa, 0xdf, 0xe7, 0xf1, 0xae, 0x81, 0xec, 0xd2, 0x84, 0xef, 0x1a, 0xc8, 0xfb,
	0xe6, 0xdf, 0xf3, 0x55, 0xf3, 0x3f, 0x5b, 0xef, 0xfe, 0x2b, 0x00, 0x00, 0xff, 0xff, 0x52, 0x55,
	0xe3, 0x0e, 0x1f, 0x13, 0x00, 0x00,
}

func (m *Value) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Value) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Value) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Default) > 0 {
		i -= len(m.Default)
		copy(dAtA[i:], m.Default)
		i = encodeVarintBpmn(dAtA, i, uint64(len(m.Default)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Value) > 0 {
		i -= len(m.Value)
		copy(dAtA[i:], m.Value)
		i = encodeVarintBpmn(dAtA, i, uint64(len(m.Value)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Kind) > 0 {
		i -= len(m.Kind)
		copy(dAtA[i:], m.Kind)
		i = encodeVarintBpmn(dAtA, i, uint64(len(m.Kind)))
		i--
		dAtA[i] = 0x12
	}
	if m.Type != 0 {
		i = encodeVarintBpmn(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Endpoint) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Endpoint) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Endpoint) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Results) > 0 {
		for k := range m.Results {
			v := m.Results[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintBpmn(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintBpmn(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintBpmn(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x6a
		}
	}
	if len(m.Parameters) > 0 {
		for k := range m.Parameters {
			v := m.Parameters[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintBpmn(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintBpmn(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintBpmn(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x62
		}
	}
	if len(m.Headers) > 0 {
		for k := range m.Headers {
			v := m.Headers[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintBpmn(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintBpmn(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintBpmn(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x5a
		}
	}
	if len(m.HttpUrl) > 0 {
		i -= len(m.HttpUrl)
		copy(dAtA[i:], m.HttpUrl)
		i = encodeVarintBpmn(dAtA, i, uint64(len(m.HttpUrl)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintBpmn(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintBpmn(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Kind) > 0 {
		i -= len(m.Kind)
		copy(dAtA[i:], m.Kind)
		i = encodeVarintBpmn(dAtA, i, uint64(len(m.Kind)))
		i--
		dAtA[i] = 0x12
	}
	if m.Type != 0 {
		i = encodeVarintBpmn(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Definitions) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Definitions) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Definitions) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.IsExecute {
		i--
		if m.IsExecute {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x50
	}
	if m.Version != 0 {
		i = encodeVarintBpmn(dAtA, i, uint64(m.Version))
		i--
		dAtA[i] = 0x48
	}
	if len(m.Content) > 0 {
		i -= len(m.Content)
		copy(dAtA[i:], m.Content)
		i = encodeVarintBpmn(dAtA, i, uint64(len(m.Content)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.Metadata) > 0 {
		for k := range m.Metadata {
			v := m.Metadata[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintBpmn(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintBpmn(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintBpmn(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x3a
		}
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintBpmn(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.Uid) > 0 {
		i -= len(m.Uid)
		copy(dAtA[i:], m.Uid)
		i = encodeVarintBpmn(dAtA, i, uint64(len(m.Uid)))
		i--
		dAtA[i] = 0x2a
	}
	if m.UpdateAt != 0 {
		i = encodeVarintBpmn(dAtA, i, uint64(m.UpdateAt))
		i--
		dAtA[i] = 0x20
	}
	if m.CreateAt != 0 {
		i = encodeVarintBpmn(dAtA, i, uint64(m.CreateAt))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintBpmn(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if m.Id != 0 {
		i = encodeVarintBpmn(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *BpmnArgs) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BpmnArgs) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BpmnArgs) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.DataObjects) > 0 {
		for k := range m.DataObjects {
			v := m.DataObjects[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintBpmn(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintBpmn(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintBpmn(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Properties) > 0 {
		for k := range m.Properties {
			v := m.Properties[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintBpmn(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintBpmn(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintBpmn(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Headers) > 0 {
		for k := range m.Headers {
			v := m.Headers[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintBpmn(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintBpmn(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintBpmn(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *Process) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Process) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Process) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ErrMsg) > 0 {
		i -= len(m.ErrMsg)
		copy(dAtA[i:], m.ErrMsg)
		i = encodeVarintBpmn(dAtA, i, uint64(len(m.ErrMsg)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x92
	}
	if m.Status != 0 {
		i = encodeVarintBpmn(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x88
	}
	if m.Stage != 0 {
		i = encodeVarintBpmn(dAtA, i, uint64(m.Stage))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x80
	}
	if m.EndAt != 0 {
		i = encodeVarintBpmn(dAtA, i, uint64(m.EndAt))
		i--
		dAtA[i] = 0x78
	}
	if m.StartAt != 0 {
		i = encodeVarintBpmn(dAtA, i, uint64(m.StartAt))
		i--
		dAtA[i] = 0x70
	}
	if m.Attempts != 0 {
		i = encodeVarintBpmn(dAtA, i, uint64(m.Attempts))
		i--
		dAtA[i] = 0x68
	}
	if m.Context != nil {
		{
			size, err := m.Context.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBpmn(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x62
	}
	if len(m.DefinitionsProcess) > 0 {
		i -= len(m.DefinitionsProcess)
		copy(dAtA[i:], m.DefinitionsProcess)
		i = encodeVarintBpmn(dAtA, i, uint64(len(m.DefinitionsProcess)))
		i--
		dAtA[i] = 0x5a
	}
	if m.DefinitionsVersion != 0 {
		i = encodeVarintBpmn(dAtA, i, uint64(m.DefinitionsVersion))
		i--
		dAtA[i] = 0x50
	}
	if len(m.DefinitionsUid) > 0 {
		i -= len(m.DefinitionsUid)
		copy(dAtA[i:], m.DefinitionsUid)
		i = encodeVarintBpmn(dAtA, i, uint64(len(m.DefinitionsUid)))
		i--
		dAtA[i] = 0x4a
	}
	if m.Args != nil {
		{
			size, err := m.Args.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintBpmn(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	if m.Priority != 0 {
		i = encodeVarintBpmn(dAtA, i, uint64(m.Priority))
		i--
		dAtA[i] = 0x38
	}
	if len(m.Metadata) > 0 {
		for k := range m.Metadata {
			v := m.Metadata[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintBpmn(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintBpmn(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintBpmn(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.Uid) > 0 {
		i -= len(m.Uid)
		copy(dAtA[i:], m.Uid)
		i = encodeVarintBpmn(dAtA, i, uint64(len(m.Uid)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintBpmn(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x22
	}
	if m.UpdateAt != 0 {
		i = encodeVarintBpmn(dAtA, i, uint64(m.UpdateAt))
		i--
		dAtA[i] = 0x18
	}
	if m.CreateAt != 0 {
		i = encodeVarintBpmn(dAtA, i, uint64(m.CreateAt))
		i--
		dAtA[i] = 0x10
	}
	if m.Id != 0 {
		i = encodeVarintBpmn(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ProcessContext) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ProcessContext) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ProcessContext) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.DataObjects) > 0 {
		for k := range m.DataObjects {
			v := m.DataObjects[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintBpmn(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintBpmn(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintBpmn(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Variables) > 0 {
		for k := range m.Variables {
			v := m.Variables[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintBpmn(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintBpmn(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintBpmn(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *FlowNode) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FlowNode) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FlowNode) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ErrMsg) > 0 {
		i -= len(m.ErrMsg)
		copy(dAtA[i:], m.ErrMsg)
		i = encodeVarintBpmn(dAtA, i, uint64(len(m.ErrMsg)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x8a
	}
	if m.Status != 0 {
		i = encodeVarintBpmn(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x80
	}
	if m.Stage != 0 {
		i = encodeVarintBpmn(dAtA, i, uint64(m.Stage))
		i--
		dAtA[i] = 0x78
	}
	if len(m.ProcessUid) > 0 {
		i -= len(m.ProcessUid)
		copy(dAtA[i:], m.ProcessUid)
		i = encodeVarintBpmn(dAtA, i, uint64(len(m.ProcessUid)))
		i--
		dAtA[i] = 0x72
	}
	if m.ProcessId != 0 {
		i = encodeVarintBpmn(dAtA, i, uint64(m.ProcessId))
		i--
		dAtA[i] = 0x68
	}
	if m.EndTime != 0 {
		i = encodeVarintBpmn(dAtA, i, uint64(m.EndTime))
		i--
		dAtA[i] = 0x60
	}
	if m.StartTime != 0 {
		i = encodeVarintBpmn(dAtA, i, uint64(m.StartTime))
		i--
		dAtA[i] = 0x58
	}
	if m.Retries != 0 {
		i = encodeVarintBpmn(dAtA, i, uint64(m.Retries))
		i--
		dAtA[i] = 0x50
	}
	if len(m.Results) > 0 {
		for k := range m.Results {
			v := m.Results[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintBpmn(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintBpmn(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintBpmn(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x4a
		}
	}
	if len(m.DataObjects) > 0 {
		for k := range m.DataObjects {
			v := m.DataObjects[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintBpmn(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintBpmn(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintBpmn(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x42
		}
	}
	if len(m.Properties) > 0 {
		for k := range m.Properties {
			v := m.Properties[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintBpmn(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintBpmn(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintBpmn(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x3a
		}
	}
	if len(m.Headers) > 0 {
		for k := range m.Headers {
			v := m.Headers[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintBpmn(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintBpmn(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintBpmn(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x32
		}
	}
	if m.FlowType != 0 {
		i = encodeVarintBpmn(dAtA, i, uint64(m.FlowType))
		i--
		dAtA[i] = 0x28
	}
	if len(m.FlowId) > 0 {
		i -= len(m.FlowId)
		copy(dAtA[i:], m.FlowId)
		i = encodeVarintBpmn(dAtA, i, uint64(len(m.FlowId)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintBpmn(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x1a
	}
	if m.CreateAt != 0 {
		i = encodeVarintBpmn(dAtA, i, uint64(m.CreateAt))
		i--
		dAtA[i] = 0x10
	}
	if m.Id != 0 {
		i = encodeVarintBpmn(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintBpmn(dAtA []byte, offset int, v uint64) int {
	offset -= sovBpmn(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *Value) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovBpmn(uint64(m.Type))
	}
	l = len(m.Kind)
	if l > 0 {
		n += 1 + l + sovBpmn(uint64(l))
	}
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovBpmn(uint64(l))
	}
	l = len(m.Default)
	if l > 0 {
		n += 1 + l + sovBpmn(uint64(l))
	}
	return n
}

func (m *Endpoint) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovBpmn(uint64(m.Type))
	}
	l = len(m.Kind)
	if l > 0 {
		n += 1 + l + sovBpmn(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovBpmn(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovBpmn(uint64(l))
	}
	l = len(m.HttpUrl)
	if l > 0 {
		n += 1 + l + sovBpmn(uint64(l))
	}
	if len(m.Headers) > 0 {
		for k, v := range m.Headers {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovBpmn(uint64(len(k))) + 1 + len(v) + sovBpmn(uint64(len(v)))
			n += mapEntrySize + 1 + sovBpmn(uint64(mapEntrySize))
		}
	}
	if len(m.Parameters) > 0 {
		for k, v := range m.Parameters {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovBpmn(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovBpmn(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovBpmn(uint64(mapEntrySize))
		}
	}
	if len(m.Results) > 0 {
		for k, v := range m.Results {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovBpmn(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovBpmn(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovBpmn(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *Definitions) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovBpmn(uint64(m.Id))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovBpmn(uint64(l))
	}
	if m.CreateAt != 0 {
		n += 1 + sovBpmn(uint64(m.CreateAt))
	}
	if m.UpdateAt != 0 {
		n += 1 + sovBpmn(uint64(m.UpdateAt))
	}
	l = len(m.Uid)
	if l > 0 {
		n += 1 + l + sovBpmn(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovBpmn(uint64(l))
	}
	if len(m.Metadata) > 0 {
		for k, v := range m.Metadata {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovBpmn(uint64(len(k))) + 1 + len(v) + sovBpmn(uint64(len(v)))
			n += mapEntrySize + 1 + sovBpmn(uint64(mapEntrySize))
		}
	}
	l = len(m.Content)
	if l > 0 {
		n += 1 + l + sovBpmn(uint64(l))
	}
	if m.Version != 0 {
		n += 1 + sovBpmn(uint64(m.Version))
	}
	if m.IsExecute {
		n += 2
	}
	return n
}

func (m *BpmnArgs) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Headers) > 0 {
		for k, v := range m.Headers {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovBpmn(uint64(len(k))) + 1 + len(v) + sovBpmn(uint64(len(v)))
			n += mapEntrySize + 1 + sovBpmn(uint64(mapEntrySize))
		}
	}
	if len(m.Properties) > 0 {
		for k, v := range m.Properties {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovBpmn(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovBpmn(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovBpmn(uint64(mapEntrySize))
		}
	}
	if len(m.DataObjects) > 0 {
		for k, v := range m.DataObjects {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovBpmn(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovBpmn(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovBpmn(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *Process) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovBpmn(uint64(m.Id))
	}
	if m.CreateAt != 0 {
		n += 1 + sovBpmn(uint64(m.CreateAt))
	}
	if m.UpdateAt != 0 {
		n += 1 + sovBpmn(uint64(m.UpdateAt))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovBpmn(uint64(l))
	}
	l = len(m.Uid)
	if l > 0 {
		n += 1 + l + sovBpmn(uint64(l))
	}
	if len(m.Metadata) > 0 {
		for k, v := range m.Metadata {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovBpmn(uint64(len(k))) + 1 + len(v) + sovBpmn(uint64(len(v)))
			n += mapEntrySize + 1 + sovBpmn(uint64(mapEntrySize))
		}
	}
	if m.Priority != 0 {
		n += 1 + sovBpmn(uint64(m.Priority))
	}
	if m.Args != nil {
		l = m.Args.Size()
		n += 1 + l + sovBpmn(uint64(l))
	}
	l = len(m.DefinitionsUid)
	if l > 0 {
		n += 1 + l + sovBpmn(uint64(l))
	}
	if m.DefinitionsVersion != 0 {
		n += 1 + sovBpmn(uint64(m.DefinitionsVersion))
	}
	l = len(m.DefinitionsProcess)
	if l > 0 {
		n += 1 + l + sovBpmn(uint64(l))
	}
	if m.Context != nil {
		l = m.Context.Size()
		n += 1 + l + sovBpmn(uint64(l))
	}
	if m.Attempts != 0 {
		n += 1 + sovBpmn(uint64(m.Attempts))
	}
	if m.StartAt != 0 {
		n += 1 + sovBpmn(uint64(m.StartAt))
	}
	if m.EndAt != 0 {
		n += 1 + sovBpmn(uint64(m.EndAt))
	}
	if m.Stage != 0 {
		n += 2 + sovBpmn(uint64(m.Stage))
	}
	if m.Status != 0 {
		n += 2 + sovBpmn(uint64(m.Status))
	}
	l = len(m.ErrMsg)
	if l > 0 {
		n += 2 + l + sovBpmn(uint64(l))
	}
	return n
}

func (m *ProcessContext) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Variables) > 0 {
		for k, v := range m.Variables {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovBpmn(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovBpmn(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovBpmn(uint64(mapEntrySize))
		}
	}
	if len(m.DataObjects) > 0 {
		for k, v := range m.DataObjects {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovBpmn(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovBpmn(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovBpmn(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *FlowNode) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovBpmn(uint64(m.Id))
	}
	if m.CreateAt != 0 {
		n += 1 + sovBpmn(uint64(m.CreateAt))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovBpmn(uint64(l))
	}
	l = len(m.FlowId)
	if l > 0 {
		n += 1 + l + sovBpmn(uint64(l))
	}
	if m.FlowType != 0 {
		n += 1 + sovBpmn(uint64(m.FlowType))
	}
	if len(m.Headers) > 0 {
		for k, v := range m.Headers {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovBpmn(uint64(len(k))) + 1 + len(v) + sovBpmn(uint64(len(v)))
			n += mapEntrySize + 1 + sovBpmn(uint64(mapEntrySize))
		}
	}
	if len(m.Properties) > 0 {
		for k, v := range m.Properties {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovBpmn(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovBpmn(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovBpmn(uint64(mapEntrySize))
		}
	}
	if len(m.DataObjects) > 0 {
		for k, v := range m.DataObjects {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovBpmn(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovBpmn(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovBpmn(uint64(mapEntrySize))
		}
	}
	if len(m.Results) > 0 {
		for k, v := range m.Results {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovBpmn(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovBpmn(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovBpmn(uint64(mapEntrySize))
		}
	}
	if m.Retries != 0 {
		n += 1 + sovBpmn(uint64(m.Retries))
	}
	if m.StartTime != 0 {
		n += 1 + sovBpmn(uint64(m.StartTime))
	}
	if m.EndTime != 0 {
		n += 1 + sovBpmn(uint64(m.EndTime))
	}
	if m.ProcessId != 0 {
		n += 1 + sovBpmn(uint64(m.ProcessId))
	}
	l = len(m.ProcessUid)
	if l > 0 {
		n += 1 + l + sovBpmn(uint64(l))
	}
	if m.Stage != 0 {
		n += 1 + sovBpmn(uint64(m.Stage))
	}
	if m.Status != 0 {
		n += 2 + sovBpmn(uint64(m.Status))
	}
	l = len(m.ErrMsg)
	if l > 0 {
		n += 2 + l + sovBpmn(uint64(l))
	}
	return n
}

func sovBpmn(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozBpmn(x uint64) (n int) {
	return sovBpmn(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Value) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBpmn
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Value: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Value: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBpmn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= Value_Type(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Kind", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBpmn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBpmn
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBpmn
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Kind = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBpmn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBpmn
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBpmn
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Default", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBpmn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBpmn
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBpmn
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Default = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBpmn(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBpmn
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Endpoint) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBpmn
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Endpoint: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Endpoint: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBpmn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= FlowNodeType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Kind", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBpmn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBpmn
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBpmn
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Kind = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBpmn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBpmn
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBpmn
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBpmn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBpmn
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBpmn
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HttpUrl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBpmn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBpmn
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBpmn
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HttpUrl = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Headers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBpmn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBpmn
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBpmn
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Headers == nil {
				m.Headers = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowBpmn
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowBpmn
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthBpmn
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthBpmn
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowBpmn
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthBpmn
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthBpmn
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipBpmn(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthBpmn
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Headers[mapkey] = mapvalue
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Parameters", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBpmn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBpmn
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBpmn
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Parameters == nil {
				m.Parameters = make(map[string]*Value)
			}
			var mapkey string
			var mapvalue *Value
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowBpmn
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowBpmn
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthBpmn
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthBpmn
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowBpmn
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthBpmn
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthBpmn
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &Value{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipBpmn(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthBpmn
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Parameters[mapkey] = mapvalue
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Results", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBpmn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBpmn
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBpmn
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Results == nil {
				m.Results = make(map[string]*Value)
			}
			var mapkey string
			var mapvalue *Value
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowBpmn
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowBpmn
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthBpmn
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthBpmn
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowBpmn
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthBpmn
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthBpmn
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &Value{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipBpmn(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthBpmn
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Results[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBpmn(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBpmn
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Definitions) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBpmn
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Definitions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Definitions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBpmn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBpmn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBpmn
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBpmn
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreateAt", wireType)
			}
			m.CreateAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBpmn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CreateAt |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateAt", wireType)
			}
			m.UpdateAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBpmn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UpdateAt |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBpmn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBpmn
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBpmn
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Uid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBpmn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBpmn
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBpmn
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBpmn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBpmn
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBpmn
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Metadata == nil {
				m.Metadata = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowBpmn
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowBpmn
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthBpmn
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthBpmn
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowBpmn
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthBpmn
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthBpmn
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipBpmn(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthBpmn
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Metadata[mapkey] = mapvalue
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Content", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBpmn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBpmn
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBpmn
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Content = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			m.Version = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBpmn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Version |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsExecute", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBpmn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsExecute = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipBpmn(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBpmn
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BpmnArgs) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBpmn
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BpmnArgs: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BpmnArgs: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Headers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBpmn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBpmn
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBpmn
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Headers == nil {
				m.Headers = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowBpmn
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowBpmn
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthBpmn
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthBpmn
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowBpmn
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthBpmn
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthBpmn
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipBpmn(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthBpmn
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Headers[mapkey] = mapvalue
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Properties", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBpmn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBpmn
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBpmn
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Properties == nil {
				m.Properties = make(map[string]*Value)
			}
			var mapkey string
			var mapvalue *Value
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowBpmn
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowBpmn
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthBpmn
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthBpmn
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowBpmn
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthBpmn
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthBpmn
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &Value{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipBpmn(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthBpmn
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Properties[mapkey] = mapvalue
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataObjects", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBpmn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBpmn
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBpmn
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DataObjects == nil {
				m.DataObjects = make(map[string]*Value)
			}
			var mapkey string
			var mapvalue *Value
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowBpmn
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowBpmn
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthBpmn
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthBpmn
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowBpmn
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthBpmn
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthBpmn
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &Value{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipBpmn(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthBpmn
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.DataObjects[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBpmn(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBpmn
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Process) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBpmn
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Process: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Process: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBpmn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreateAt", wireType)
			}
			m.CreateAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBpmn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CreateAt |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateAt", wireType)
			}
			m.UpdateAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBpmn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UpdateAt |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBpmn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBpmn
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBpmn
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBpmn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBpmn
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBpmn
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Uid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBpmn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBpmn
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBpmn
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Metadata == nil {
				m.Metadata = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowBpmn
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowBpmn
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthBpmn
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthBpmn
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowBpmn
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthBpmn
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthBpmn
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipBpmn(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthBpmn
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Metadata[mapkey] = mapvalue
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Priority", wireType)
			}
			m.Priority = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBpmn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Priority |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Args", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBpmn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBpmn
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBpmn
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Args == nil {
				m.Args = &BpmnArgs{}
			}
			if err := m.Args.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefinitionsUid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBpmn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBpmn
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBpmn
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DefinitionsUid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefinitionsVersion", wireType)
			}
			m.DefinitionsVersion = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBpmn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DefinitionsVersion |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefinitionsProcess", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBpmn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBpmn
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBpmn
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DefinitionsProcess = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Context", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBpmn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBpmn
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBpmn
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Context == nil {
				m.Context = &ProcessContext{}
			}
			if err := m.Context.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Attempts", wireType)
			}
			m.Attempts = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBpmn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Attempts |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartAt", wireType)
			}
			m.StartAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBpmn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StartAt |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndAt", wireType)
			}
			m.EndAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBpmn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EndAt |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stage", wireType)
			}
			m.Stage = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBpmn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Stage |= Process_ProcessStage(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBpmn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= Process_ProcessStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrMsg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBpmn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBpmn
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBpmn
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ErrMsg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBpmn(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBpmn
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ProcessContext) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBpmn
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ProcessContext: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ProcessContext: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Variables", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBpmn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBpmn
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBpmn
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Variables == nil {
				m.Variables = make(map[string]*Value)
			}
			var mapkey string
			var mapvalue *Value
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowBpmn
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowBpmn
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthBpmn
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthBpmn
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowBpmn
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthBpmn
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthBpmn
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &Value{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipBpmn(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthBpmn
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Variables[mapkey] = mapvalue
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataObjects", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBpmn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBpmn
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBpmn
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DataObjects == nil {
				m.DataObjects = make(map[string]*Value)
			}
			var mapkey string
			var mapvalue *Value
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowBpmn
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowBpmn
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthBpmn
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthBpmn
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowBpmn
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthBpmn
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthBpmn
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &Value{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipBpmn(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthBpmn
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.DataObjects[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBpmn(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBpmn
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FlowNode) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBpmn
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FlowNode: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FlowNode: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBpmn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreateAt", wireType)
			}
			m.CreateAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBpmn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CreateAt |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBpmn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBpmn
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBpmn
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FlowId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBpmn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBpmn
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBpmn
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FlowId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FlowType", wireType)
			}
			m.FlowType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBpmn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FlowType |= FlowNodeType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Headers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBpmn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBpmn
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBpmn
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Headers == nil {
				m.Headers = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowBpmn
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowBpmn
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthBpmn
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthBpmn
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowBpmn
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthBpmn
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthBpmn
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipBpmn(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthBpmn
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Headers[mapkey] = mapvalue
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Properties", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBpmn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBpmn
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBpmn
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Properties == nil {
				m.Properties = make(map[string]*Value)
			}
			var mapkey string
			var mapvalue *Value
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowBpmn
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowBpmn
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthBpmn
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthBpmn
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowBpmn
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthBpmn
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthBpmn
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &Value{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipBpmn(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthBpmn
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Properties[mapkey] = mapvalue
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataObjects", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBpmn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBpmn
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBpmn
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DataObjects == nil {
				m.DataObjects = make(map[string]*Value)
			}
			var mapkey string
			var mapvalue *Value
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowBpmn
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowBpmn
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthBpmn
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthBpmn
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowBpmn
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthBpmn
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthBpmn
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &Value{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipBpmn(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthBpmn
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.DataObjects[mapkey] = mapvalue
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Results", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBpmn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBpmn
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBpmn
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Results == nil {
				m.Results = make(map[string]*Value)
			}
			var mapkey string
			var mapvalue *Value
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowBpmn
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowBpmn
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthBpmn
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthBpmn
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowBpmn
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthBpmn
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthBpmn
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &Value{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipBpmn(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthBpmn
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Results[mapkey] = mapvalue
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Retries", wireType)
			}
			m.Retries = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBpmn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Retries |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartTime", wireType)
			}
			m.StartTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBpmn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StartTime |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndTime", wireType)
			}
			m.EndTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBpmn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EndTime |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProcessId", wireType)
			}
			m.ProcessId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBpmn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ProcessId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProcessUid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBpmn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBpmn
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBpmn
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProcessUid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stage", wireType)
			}
			m.Stage = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBpmn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Stage |= FlowNode_FlowNodeStage(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBpmn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= FlowNode_FlowNodeStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrMsg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBpmn
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBpmn
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBpmn
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ErrMsg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBpmn(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBpmn
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipBpmn(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowBpmn
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowBpmn
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowBpmn
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthBpmn
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupBpmn
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthBpmn
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthBpmn        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowBpmn          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupBpmn = fmt.Errorf("proto: unexpected end of group")
)
